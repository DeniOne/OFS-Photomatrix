# Архитектура взаимодействия Telegram бота с API

## 1. Структура API клиента (api_client.py)

**ApiClient** класс предоставляет всю необходимую функциональность для взаимодействия с бэкендом:

- **Инициализация**: Получает настройки из config.py, включая URL API и токен доступа
- **Аутентификация**: Использует заголовок X-API-Key для аутентификации запросов
- **Методы для работы с данными**:
  - `get_positions()` - получает список должностей
  - `get_position_by_id(position_id)` - получает информацию о конкретной должности
  - `get_organizations()` - получает список организаций
  - `get_divisions()` - получает список отделов
  - `send_employee_data(employee_data)` - отправляет данные сотрудника
  - `validate_token(token)` - проверяет валидность токена
  - `create_staff(staff_data)` - создает запись о сотруднике
  - `generate_invitation_code(data)` - генерирует код приглашения
  - `validate_invitation_code(code, telegram_id)` - проверяет код приглашения

## 2. Точки взаимодействия с API

1. **Эндпоинты Telegram-бота**:
   - `/telegram-bot/webhook` - для получения обновлений
   - `/telegram-bot/validate-token` - для валидации токена
   - `/telegram-bot/organizations` - для получения списка организаций
   - `/telegram-bot/generate-invitation` - для генерации кода приглашения
   - `/telegram-bot/validate-invitation` - для проверки кода приглашения

2. **Обработка ответов от API**:
   - Каждый метод возвращает словарь с ключами `success`, `message` и `result`
   - Все ответы логируются для отладки
   - В случае ошибок возвращается детальная информация о проблеме

## 3. Процесс регистрации пользователя

1. **Этап сбора данных**:
   - Пользователь нажимает "Зарегистрироваться"
   - Вводит имя или подтверждает имя из Telegram
   - Выбирает организацию из списка (получается через API)
   - Вводит или выбирает должность (должности получаются через API)
   - Опционально выбирает отдел (отделы получаются через API)
   - Подтверждает данные

2. **Обработка заявки**:
   - Создается локальная запись о запросе
   - Отправляется предварительный запрос через `create_staff()`
   - Администратор получает уведомление о новой заявке

3. **После одобрения заявки**:
   - Генерируется код приглашения через `generate_invitation_code()`
   - Пользователь вводит код
   - Код проверяется через `validate_invitation_code()`
   - Пользователь загружает фото и дополнительные данные

## 4. Структура данных в базе

1. **Основные модели**:
   - `User` - пользователь системы (email, password, активация)
   - `Staff` - информация о сотруднике (ФИО, контакты, фото)
   - `Organization` - организации
   - `Position` - должности
   - `Division` - отделы
   - `StaffPosition` - связь сотрудников с должностями (многие ко многим)

2. **Связи между моделями**:
   - Пользователь (User) связан с сотрудником (Staff) через one-to-one отношение
   - Сотрудник (Staff) может занимать несколько должностей (Position) через StaffPosition
   - Должность (Position) может быть привязана к отделу (Division)

## 5. Механизм приглашений и токенов

1. **Генерация приглашений**:
   - Создается код для конкретной должности, отдела и Telegram ID
   - Код имеет ограниченный срок действия

2. **Проверка приглашений**:
   - Код проверяется на валидность и привязку к пользователю
   - При успешной проверке возвращаются данные о должности, отделе и организации

## 6. Особенности интерфейса

1. **Клавиатуры**:
   - Динамически генерируются на основе данных из API
   - Отображают актуальные списки организаций, должностей и отделов
   - Позволяют легко перемещаться между шагами процесса

2. **Состояния (FSM)**:
   - `RegistrationStates` управляют процессом регистрации
   - `AdminStates` управляют администраторскими функциями

## 7. Обработка ошибок

- Каждый запрос к API обернут в try-except для перехвата всех исключений
- Ошибки логируются и возвращаются пользователю в понятном формате
- При проблемах с API процесс регистрации деградирует корректно

## 8. Оптимизация и масштабирование

- Использование асинхронных запросов для эффективного использования ресурсов
- Централизованная конфигурация для упрощения изменений в API или процессах
- Возможность добавления новых методов без изменения основной логики бота 